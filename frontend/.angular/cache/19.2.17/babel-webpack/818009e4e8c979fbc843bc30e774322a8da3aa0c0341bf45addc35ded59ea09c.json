{"ast":null,"code":"import { of } from 'rxjs';\n// Necesario importar map de rxjs\nimport { map } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./encuestas.service\";\n// Esto le dice a Angular que esta clase es un servicio que se puede usar en toda la app\nexport let ExportService = /*#__PURE__*/(() => {\n  class ExportService {\n    encuestasService;\n    constructor(encuestasService) {\n      this.encuestasService = encuestasService;\n    }\n    exportarEncuestaCSV(encuestaId, opciones = {}) {\n      try {\n        // Configuracion por defecto para la exportacion\n        const configuracion = {\n          incluirMetadatos: true,\n          // Si incluir informacion extra\n          incluirRespuestasVacias: false,\n          // No incluir respuestas vacias\n          formatoFecha: 'dd/MM/yyyy',\n          // Formato de fecha colombiano\n          separador: ',',\n          // Separar columnas con comas\n          ...opciones // Sobrescribir con opciones del usuario\n        };\n        let csvContent = ''; // Aqui se va armando el archivo CSV\n        const sep = configuracion.separador; // Atajo para el separador\n        // Traer todos los datos necesarios para crear el reporte\n        const encuestas = this.encuestasService.obtenerEncuestas();\n        const respuestas = this.encuestasService.obtenerRespuestas();\n        const usuarios = this.encuestasService.obtenerUsuarios();\n        // Procesar los datos cuando lleguen\n        encuestas.subscribe(enc => {\n          const encuesta = enc.find(e => e.id === encuestaId); // Buscar la encuesta especifica\n          if (!encuesta) {\n            throw new Error('Encuesta no encontrada');\n          }\n          respuestas.subscribe(resp => {\n            usuarios.subscribe(usu => {\n              const respuestasEncuesta = resp.filter(r => r.encuestaId === encuestaId);\n              // Metadatos de la encuesta\n              if (configuracion.incluirMetadatos) {\n                csvContent += `# Exportación de Encuesta\\n`;\n                csvContent += `# Título${sep}${this.escaparCSV(encuesta.titulo)}\\n`;\n                csvContent += `# Descripción${sep}${this.escaparCSV(encuesta.descripcion)}\\n`;\n                csvContent += `# Fecha Creación${sep}${this.formatearFecha(encuesta.fechaCreacion, configuracion.formatoFecha)}\\n`;\n                csvContent += `# Fecha Límite${sep}${this.formatearFecha(encuesta.fechaLimite, configuracion.formatoFecha)}\\n`;\n                csvContent += `# Estado${sep}${encuesta.estado}\\n`;\n                csvContent += `# Total Respuestas${sep}${respuestasEncuesta.length}\\n`;\n                csvContent += `# Fecha Exportación${sep}${this.formatearFecha(new Date(), configuracion.formatoFecha)}\\n`;\n                csvContent += `\\n`;\n              }\n              // Encabezados\n              let encabezados = ['ID_Respuesta', 'Usuario_ID', 'Usuario_Nombre', 'Usuario_Email', 'Usuario_Rol', 'Fecha_Respuesta', 'Tiempo_Respuesta_Segundos', 'IP_Address'];\n              // Agregar columnas por cada pregunta\n              encuesta.preguntas.forEach(pregunta => {\n                encabezados.push(`P${pregunta.id}_${this.limpiarNombreColumna(pregunta.texto)}`);\n              });\n              csvContent += encabezados.join(sep) + '\\n';\n              // Datos de respuestas\n              respuestasEncuesta.forEach(respuesta => {\n                const usuario = usu.find(u => u.id === respuesta.usuarioId);\n                let fila = [respuesta.id.toString(), respuesta.usuarioId.toString(), usuario ? this.escaparCSV(usuario.nombre) : 'Usuario no encontrado', usuario ? this.escaparCSV(usuario.email) : '', usuario ? usuario.rol : '', this.formatearFecha(respuesta.fechaCompletado, configuracion.formatoFecha), (respuesta.tiempoRespuesta || 0).toString(), respuesta.ipAddress || ''];\n                // Agregar respuestas por pregunta\n                encuesta.preguntas.forEach(pregunta => {\n                  const valorRespuesta = respuesta.respuestas[pregunta.id];\n                  if (valorRespuesta !== undefined && valorRespuesta !== null) {\n                    fila.push(this.escaparCSV(valorRespuesta.toString()));\n                  } else {\n                    fila.push(configuracion.incluirRespuestasVacias ? '' : 'Sin respuesta');\n                  }\n                });\n                csvContent += fila.join(sep) + '\\n';\n              });\n              // Si no hay respuestas y se incluyen vacías\n              if (respuestasEncuesta.length === 0 && configuracion.incluirRespuestasVacias) {\n                let filaVacia = new Array(encabezados.length).fill('');\n                csvContent += filaVacia.join(sep) + '\\n';\n              }\n            });\n          });\n        });\n        const filename = `encuesta_${encuestaId}_${this.obtenerTimestamp()}.csv`;\n        return of({\n          success: true,\n          data: csvContent,\n          filename: filename\n        });\n      } catch (error) {\n        return of({\n          success: false,\n          error: error instanceof Error ? error.message : 'Error desconocido al exportar'\n        });\n      }\n    }\n    exportarEstadisticasCSV(encuestaId) {\n      return this.encuestasService.obtenerEstadisticasEncuesta(encuestaId).pipe(map(estadisticas => {\n        if (!estadisticas) {\n          return {\n            success: false,\n            error: 'No se pudieron obtener las estadísticas'\n          };\n        }\n        try {\n          let csvContent = '';\n          const sep = ',';\n          // Información general\n          csvContent += `# Estadísticas de Encuesta\\n`;\n          csvContent += `# Título,${this.escaparCSV(estadisticas.titulo)}\\n`;\n          csvContent += `# Total Respuestas,${estadisticas.totalRespuestas}\\n`;\n          csvContent += `# Tiempo Promedio Respuesta,${Math.round(estadisticas.tiempoPromedioRespuesta)} segundos\\n`;\n          csvContent += `\\n`;\n          // Análisis por pregunta\n          csvContent += `Pregunta_ID,Texto_Pregunta,Tipo,Total_Respuestas,Análisis\\n`;\n          estadisticas.preguntasAnalisis.forEach(analisis => {\n            let textoAnalisis = '';\n            if (analisis.tipo === 'escala') {\n              textoAnalisis = `Promedio: ${analisis.promedio?.toFixed(2) || 0}`;\n              if (analisis.distribucion) {\n                const dist = Object.entries(analisis.distribucion).map(([valor, cantidad]) => `${valor}: ${cantidad}`).join('; ');\n                textoAnalisis += ` | Distribución: ${dist}`;\n              }\n            } else if (analisis.tipo === 'multiple') {\n              if (analisis.distribucion) {\n                textoAnalisis = Object.entries(analisis.distribucion).map(([opcion, cantidad]) => `${opcion}: ${cantidad}`).join('; ');\n              }\n            } else if (analisis.tipo === 'abierta') {\n              textoAnalisis = `${analisis.totalRespuestas} respuestas de texto`;\n            }\n            csvContent += [analisis.preguntaId, this.escaparCSV(analisis.texto), analisis.tipo, analisis.totalRespuestas, this.escaparCSV(textoAnalisis)].join(sep) + '\\n';\n          });\n          const filename = `estadisticas_encuesta_${encuestaId}_${this.obtenerTimestamp()}.csv`;\n          return {\n            success: true,\n            data: csvContent,\n            filename: filename\n          };\n        } catch (error) {\n          return {\n            success: false,\n            error: error instanceof Error ? error.message : 'Error al generar estadísticas CSV'\n          };\n        }\n      }));\n    }\n    exportarUsuariosCSV() {\n      return this.encuestasService.obtenerUsuarios().pipe(map(usuarios => {\n        try {\n          let csvContent = '';\n          const sep = ',';\n          // Encabezados\n          csvContent += ['ID', 'Nombre', 'Email', 'Rol', 'Fecha_Registro', 'Estado'].join(sep) + '\\n';\n          // Datos de usuarios\n          usuarios.forEach(usuario => {\n            csvContent += [usuario.id.toString(), this.escaparCSV(usuario.nombre), this.escaparCSV(usuario.email), usuario.rol, this.formatearFecha(usuario.fechaRegistro, 'dd/MM/yyyy'), usuario.activo ? 'Activo' : 'Inactivo'].join(sep) + '\\n';\n          });\n          const filename = `usuarios_${this.obtenerTimestamp()}.csv`;\n          return {\n            success: true,\n            data: csvContent,\n            filename: filename\n          };\n        } catch (error) {\n          return {\n            success: false,\n            error: error instanceof Error ? error.message : 'Error al exportar usuarios'\n          };\n        }\n      }));\n    }\n    descargarCSV(data, filename) {\n      // Agregar BOM para compatibilidad con Excel\n      const BOM = '\\uFEFF';\n      const csvData = BOM + data;\n      const blob = new Blob([csvData], {\n        type: 'text/csv;charset=utf-8;'\n      });\n      const link = document.createElement('a');\n      if (link.download !== undefined) {\n        const url = URL.createObjectURL(blob);\n        link.setAttribute('href', url);\n        link.setAttribute('download', filename);\n        link.style.visibility = 'hidden';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        URL.revokeObjectURL(url);\n      }\n    }\n    escaparCSV(valor) {\n      if (typeof valor !== 'string') {\n        valor = String(valor);\n      }\n      // Escapar comillas dobles duplicándolas\n      valor = valor.replace(/\"/g, '\"\"');\n      // Envolver en comillas si contiene separadores, saltos de línea o comillas\n      if (valor.includes(',') || valor.includes(';') || valor.includes('\\n') || valor.includes('\\r') || valor.includes('\"')) {\n        valor = `\"${valor}\"`;\n      }\n      return valor;\n    }\n    limpiarNombreColumna(texto) {\n      return texto.replace(/[^\\w\\sáéíóúüñ]/gi, '') // Remover caracteres especiales excepto espacios y acentos\n      .replace(/\\s+/g, '_') // Reemplazar espacios con guiones bajos\n      .substring(0, 50); // Limitar longitud\n    }\n    formatearFecha(fecha, formato) {\n      const dia = fecha.getDate().toString().padStart(2, '0');\n      const mes = (fecha.getMonth() + 1).toString().padStart(2, '0');\n      const año = fecha.getFullYear().toString();\n      switch (formato) {\n        case 'dd/MM/yyyy':\n          return `${dia}/${mes}/${año}`;\n        case 'yyyy-MM-dd':\n          return `${año}-${mes}-${dia}`;\n        case 'MM/dd/yyyy':\n          return `${mes}/${dia}/${año}`;\n        default:\n          return `${dia}/${mes}/${año}`;\n      }\n    }\n    obtenerTimestamp() {\n      const ahora = new Date();\n      const año = ahora.getFullYear();\n      const mes = (ahora.getMonth() + 1).toString().padStart(2, '0');\n      const dia = ahora.getDate().toString().padStart(2, '0');\n      const hora = ahora.getHours().toString().padStart(2, '0');\n      const minuto = ahora.getMinutes().toString().padStart(2, '0');\n      return `${año}${mes}${dia}_${hora}${minuto}`;\n    }\n    static ɵfac = function ExportService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ExportService)(i0.ɵɵinject(i1.EncuestasService));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: ExportService,\n      factory: ExportService.ɵfac,\n      providedIn: 'root' // Hacer que este servicio este disponible en toda la aplicacion\n    });\n  }\n  return ExportService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}