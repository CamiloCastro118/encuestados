{"ast":null,"code":"import { of } from 'rxjs';\nimport * as i0 from \"@angular/core\";\n// Esto le dice a Angular que esta clase es un servicio que se puede usar en toda la app\nexport let SecurityService = /*#__PURE__*/(() => {\n  class SecurityService {\n    sesionesActivas = new Map();\n    ipsBloqueadas = new Set();\n    respuestasRecientes = new Map();\n    // Aqui ponemos las reglas de seguridad\n    CONFIG = {\n      TIEMPO_MINIMO_RESPUESTA: 30,\n      // Minimo 30 segundos para responder\n      TIEMPO_MAXIMO_RESPUESTA: 3600,\n      // Maximo 1 hora o se vence\n      MAX_INTENTOS_POR_HORA: 5,\n      // Solo 5 intentos por hora\n      MAX_RESPUESTAS_POR_IP_DIA: 50,\n      // Maximo 50 respuestas por dia desde la misma computadora\n      TIEMPO_BLOQUEO_IP: 24 * 60 * 60 * 1000,\n      // 24 horas de castigo\n      // Palabras que no se pueden usar en las respuestas\n      PALABRAS_SPAM: ['spam', 'fake', 'test', 'prueba', 'aaa', 'bbb', 'ccc', 'asdfgh', 'qwerty', '123456', 'aaaaa', 'nnnnn'],\n      // Patrones sospechosos en las respuestas\n      PATRONES_SOSPECHOSOS: [/(.)\\1{4,}/,\n      // Letras repetidas muchas veces\n      /^[a-z]{1,3}$/i,\n      // Respuestas muy cortas\n      /^\\d+$/,\n      // Solo numeros\n      /^[^a-zA-Z0-9\\s]+$/ // Solo caracteres raros\n      ]\n    };\n    constructor() {\n      // Cada 30 minutos limpiamos las sesiones viejas para no llenar la memoria\n      setInterval(() => {\n        this.limpiarSesionesExpiradas();\n      }, 30 * 60 * 1000);\n    }\n    // Crear una nueva sesion cuando alguien entra al sistema\n    inicializarSesion(userId, ipAddress, userAgent) {\n      // Creamos un ID unico para esta sesion\n      const sessionId = this.generarSessionId(userId, ipAddress);\n      // Guardamos toda la informacion del usuario\n      const sesion = {\n        userId,\n        ipAddress,\n        userAgent,\n        sessionStart: new Date(),\n        // Cuando empezo\n        lastActivity: new Date(),\n        // Ultima actividad\n        encuestasRespondidas: [],\n        // Lista vacia al inicio\n        intentosRespuesta: 0,\n        // Sin intentos al inicio\n        bloqueado: false // No esta bloqueado al inicio\n      };\n      // Guardamos la sesion en memoria\n      this.sesionesActivas.set(sessionId, sesion);\n      return sessionId;\n    }\n    // Revisar si el usuario puede ver una encuesta antes de mostrarla\n    validarAccesoEncuesta(sessionId, encuestaId) {\n      // Buscamos la sesion del usuario\n      const sesion = this.sesionesActivas.get(sessionId);\n      // Si no tiene sesion valida, no puede continuar\n      if (!sesion) {\n        return of({\n          isValid: false,\n          message: 'Sesion no valida. Por favor, inicia sesion nuevamente.',\n          riskLevel: 'high',\n          blocked: true\n        });\n      }\n      // Revisar si la computadora esta castigada\n      if (this.ipsBloqueadas.has(sesion.ipAddress)) {\n        return of({\n          isValid: false,\n          message: 'Tu direccion IP ha sido bloqueada temporalmente por actividad sospechosa.',\n          riskLevel: 'high',\n          blocked: true\n        });\n      }\n      // Revisar si ya respondio esta encuesta antes\n      if (sesion.encuestasRespondidas.includes(encuestaId)) {\n        return of({\n          isValid: false,\n          message: 'Ya has respondido esta encuesta.',\n          riskLevel: 'medium',\n          blocked: true\n        });\n      }\n      // Contar cuantas respuestas ha dado hoy desde esta computadora\n      const respuestasHoy = this.contarRespuestasIPHoy(sesion.ipAddress);\n      if (respuestasHoy >= this.CONFIG.MAX_RESPUESTAS_POR_IP_DIA) {\n        // Si ya respondio demasiado, castigar la IP\n        this.bloquearIP(sesion.ipAddress);\n        return of({\n          isValid: false,\n          message: 'Has excedido el limite diario de respuestas desde esta direccion IP.',\n          riskLevel: 'high',\n          blocked: true\n        });\n      }\n      // Revisar si ha intentado responder demasiado rapido\n      if (sesion.intentosRespuesta > this.CONFIG.MAX_INTENTOS_POR_HORA) {\n        // Castigar al usuario por intentar hacer trampa\n        sesion.bloqueado = true;\n        sesion.tiempoBloqueo = new Date(Date.now() + this.CONFIG.TIEMPO_BLOQUEO_IP);\n        return of({\n          isValid: false,\n          message: 'Has excedido el limite de intentos por hora. Intentalo mas tarde.',\n          riskLevel: 'high',\n          blocked: true\n        });\n      }\n      // Si paso todas las pruebas, puede continuar\n      return of({\n        isValid: true,\n        message: 'Acceso autorizado',\n        riskLevel: 'low',\n        blocked: false\n      });\n    }\n    // Validar respuesta antes de enviar\n    validarRespuesta(sessionId, encuestaId, respuestas, tiempoRespuesta) {\n      const sesion = this.sesionesActivas.get(sessionId);\n      if (!sesion) {\n        return of({\n          isValid: false,\n          message: 'Sesión expirada',\n          riskLevel: 'high',\n          blocked: true\n        });\n      }\n      // Validar tiempo de respuesta\n      if (tiempoRespuesta < this.CONFIG.TIEMPO_MINIMO_RESPUESTA) {\n        sesion.intentosRespuesta++;\n        return of({\n          isValid: false,\n          message: `Respuesta enviada muy rápido. Tómate al menos ${this.CONFIG.TIEMPO_MINIMO_RESPUESTA} segundos para leer las preguntas.`,\n          riskLevel: 'high',\n          blocked: false\n        });\n      }\n      if (tiempoRespuesta > this.CONFIG.TIEMPO_MAXIMO_RESPUESTA) {\n        return of({\n          isValid: false,\n          message: 'La sesión ha expirado. Por favor, vuelve a cargar la encuesta.',\n          riskLevel: 'medium',\n          blocked: false\n        });\n      }\n      // Analizar contenido de respuestas\n      const analisisContenido = this.analizarContenidoRespuestas(respuestas);\n      if (!analisisContenido.isValid) {\n        sesion.intentosRespuesta++;\n        return of(analisisContenido);\n      }\n      // Validar patrones de comportamiento\n      const analisisComportamiento = this.analizarPatronesComportamiento(sesion, tiempoRespuesta);\n      if (!analisisComportamiento.isValid) {\n        return of(analisisComportamiento);\n      }\n      // Registrar respuesta exitosa\n      this.registrarRespuestaExitosa(sessionId, encuestaId, sesion.ipAddress);\n      return of({\n        isValid: true,\n        message: 'Respuesta válida',\n        riskLevel: 'low',\n        blocked: false\n      });\n    }\n    // Analizar contenido de respuestas\n    analizarContenidoRespuestas(respuestas) {\n      const textos = [];\n      // Extraer todas las respuestas de texto\n      Object.values(respuestas).forEach(respuesta => {\n        if (typeof respuesta === 'string' && respuesta.trim().length > 0) {\n          textos.push(respuesta.toLowerCase().trim());\n        }\n      });\n      // Verificar palabras spam\n      for (const texto of textos) {\n        for (const palabraSpam of this.CONFIG.PALABRAS_SPAM) {\n          if (texto.includes(palabraSpam.toLowerCase())) {\n            return {\n              isValid: false,\n              message: 'Se detectó contenido potencialmente spam en las respuestas.',\n              riskLevel: 'high',\n              blocked: false\n            };\n          }\n        }\n        // Verificar patrones sospechosos\n        for (const patron of this.CONFIG.PATRONES_SOSPECHOSOS) {\n          if (patron.test(texto)) {\n            return {\n              isValid: false,\n              message: 'Se detectó un patrón sospechoso en las respuestas. Por favor, proporciona respuestas más detalladas.',\n              riskLevel: 'medium',\n              blocked: false\n            };\n          }\n        }\n      }\n      // Verificar respuestas idénticas\n      const respuestasUnicas = new Set(textos);\n      if (textos.length > 1 && respuestasUnicas.size === 1) {\n        return {\n          isValid: false,\n          message: 'Se detectaron respuestas idénticas. Por favor, proporciona respuestas variadas.',\n          riskLevel: 'medium',\n          blocked: false\n        };\n      }\n      return {\n        isValid: true,\n        message: 'Contenido válido',\n        riskLevel: 'low',\n        blocked: false\n      };\n    }\n    // Analizar patrones de comportamiento\n    analizarPatronesComportamiento(sesion, tiempoRespuesta) {\n      // Verificar si el tiempo de respuesta es sospechosamente constante\n      const respuestasRecientesKey = `${sesion.userId}_${sesion.ipAddress}`;\n      const tiemposAnteriores = this.respuestasRecientes.get(respuestasRecientesKey) || [];\n      if (tiemposAnteriores.length >= 3) {\n        // Si todos los tiempos son muy similares (diferencia menor a 5 segundos)\n        const tiemposSegundos = tiemposAnteriores.map(t => Math.floor((Date.now() - t.getTime()) / 1000));\n        const diferenciasMinimas = tiemposSegundos.every((tiempo, index, arr) => {\n          if (index === 0) return true;\n          return Math.abs(tiempo - arr[index - 1]) < 5;\n        });\n        if (diferenciasMinimas) {\n          return {\n            isValid: false,\n            message: 'Se detectó un patrón de respuesta automatizado.',\n            riskLevel: 'high',\n            blocked: false\n          };\n        }\n      }\n      return {\n        isValid: true,\n        message: 'Comportamiento normal',\n        riskLevel: 'low',\n        blocked: false\n      };\n    }\n    // Registrar respuesta exitosa\n    registrarRespuestaExitosa(sessionId, encuestaId, ipAddress) {\n      const sesion = this.sesionesActivas.get(sessionId);\n      if (sesion) {\n        sesion.encuestasRespondidas.push(encuestaId);\n        sesion.lastActivity = new Date();\n        sesion.intentosRespuesta = 0; // Reset contador de intentos\n      }\n      // Registrar tiempo de respuesta por IP\n      const key = `${sesion?.userId}_${ipAddress}`;\n      const tiempos = this.respuestasRecientes.get(key) || [];\n      tiempos.push(new Date());\n      // Mantener solo los últimos 5 tiempos\n      if (tiempos.length > 5) {\n        tiempos.splice(0, tiempos.length - 5);\n      }\n      this.respuestasRecientes.set(key, tiempos);\n    }\n    // Contar respuestas de IP en las últimas 24 horas\n    contarRespuestasIPHoy(ipAddress) {\n      const hace24Horas = new Date(Date.now() - 24 * 60 * 60 * 1000);\n      let contador = 0;\n      this.respuestasRecientes.forEach((tiempos, key) => {\n        if (key.includes(ipAddress)) {\n          contador += tiempos.filter(tiempo => tiempo > hace24Horas).length;\n        }\n      });\n      return contador;\n    }\n    // Bloquear IP\n    bloquearIP(ipAddress) {\n      this.ipsBloqueadas.add(ipAddress);\n      // Desbloquear automáticamente después del tiempo configurado\n      setTimeout(() => {\n        this.ipsBloqueadas.delete(ipAddress);\n      }, this.CONFIG.TIEMPO_BLOQUEO_IP);\n    }\n    // Generar ID de sesión\n    generarSessionId(userId, ipAddress) {\n      const timestamp = Date.now().toString();\n      const random = Math.random().toString(36).substring(2);\n      return `${userId}_${ipAddress.replace(/\\./g, '_')}_${timestamp}_${random}`;\n    }\n    // Limpiar sesiones expiradas\n    limpiarSesionesExpiradas() {\n      const hace2Horas = new Date(Date.now() - 2 * 60 * 60 * 1000);\n      this.sesionesActivas.forEach((sesion, sessionId) => {\n        if (sesion.lastActivity < hace2Horas) {\n          this.sesionesActivas.delete(sessionId);\n        }\n      });\n      // Limpiar respuestas recientes antiguas\n      this.respuestasRecientes.forEach((tiempos, key) => {\n        const tiemposFiltrados = tiempos.filter(tiempo => tiempo > hace2Horas);\n        if (tiemposFiltrados.length === 0) {\n          this.respuestasRecientes.delete(key);\n        } else {\n          this.respuestasRecientes.set(key, tiemposFiltrados);\n        }\n      });\n    }\n    // Obtener estadísticas de seguridad\n    obtenerEstadisticasSeguridad() {\n      return of({\n        sesionesActivas: this.sesionesActivas.size,\n        ipsBloqueadas: this.ipsBloqueadas.size,\n        respuestasRecientes24h: Array.from(this.respuestasRecientes.values()).flat().filter(tiempo => tiempo > new Date(Date.now() - 24 * 60 * 60 * 1000)).length,\n        configuracion: this.CONFIG\n      });\n    }\n    // Desbloquear IP manualmente (para administradores)\n    desbloquearIP(ipAddress) {\n      this.ipsBloqueadas.delete(ipAddress);\n    }\n    // Obtener IPs bloqueadas\n    obtenerIPsBloqueadas() {\n      return Array.from(this.ipsBloqueadas);\n    }\n    static ɵfac = function SecurityService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SecurityService)();\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: SecurityService,\n      factory: SecurityService.ɵfac,\n      providedIn: 'root' // Hacer que este servicio este disponible en toda la aplicacion\n    });\n  }\n  return SecurityService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}