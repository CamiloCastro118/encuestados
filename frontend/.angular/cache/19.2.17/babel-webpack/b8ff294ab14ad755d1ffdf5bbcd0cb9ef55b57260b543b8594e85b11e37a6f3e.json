{"ast":null,"code":"import { BehaviorSubject, of, throwError } from 'rxjs';\nimport { map, switchMap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./security.service\";\n// Esto le dice a Angular que esta clase es un servicio que se puede usar en toda la app\nexport let EncuestasService = /*#__PURE__*/(() => {\n  class EncuestasService {\n    securityService;\n    // Contenedores de datos que pueden cambiar y avisar a las paginas cuando cambian\n    encuestasSubject = new BehaviorSubject([]); // Lista de encuestas\n    respuestasSubject = new BehaviorSubject([]); // Lista de respuestas\n    usuariosSubject = new BehaviorSubject([]); // Lista de usuarios\n    sesionesUsuario = new Map(); // Guardar sesiones activas\n    // Versiones publicas que las paginas pueden leer (pero no modificar directamente)\n    encuestas$ = this.encuestasSubject.asObservable(); // Para que los componentes vean las encuestas\n    respuestas$ = this.respuestasSubject.asObservable(); // Para que los componentes vean las respuestas\n    usuarios$ = this.usuariosSubject.asObservable(); // Para que los componentes vean los usuarios\n    constructor(securityService) {\n      this.securityService = securityService;\n      this.inicializarDatos();\n    }\n    inicializarDatos() {\n      // Datos iniciales de usuarios\n      const usuariosIniciales = [{\n        id: 1,\n        nombre: 'Juan Pérez',\n        email: 'juan.perez@universidad.edu',\n        rol: 'encuestado',\n        fechaRegistro: new Date('2024-01-15'),\n        activo: true\n      }, {\n        id: 3,\n        nombre: 'Carlos López',\n        email: 'carlos.lopez@universidad.edu',\n        rol: 'directivo',\n        fechaRegistro: new Date('2024-01-20'),\n        activo: true\n      }, {\n        id: 4,\n        nombre: 'Ana Martínez',\n        email: 'ana.martinez@universidad.edu',\n        rol: 'administrador',\n        fechaRegistro: new Date('2024-01-01'),\n        activo: true\n      }];\n      // Datos iniciales de encuestas\n      const encuestasIniciales = [{\n        id: 1,\n        titulo: 'Satisfacción del Servicio',\n        descripcion: 'Encuesta para evaluar la calidad del servicio prestado',\n        fechaCreacion: new Date('2025-10-01'),\n        fechaLimite: new Date('2025-12-31'),\n        estado: 'activa',\n        creadorId: 4,\n        preguntas: [{\n          id: 1,\n          texto: '¿Cómo califica el servicio recibido?',\n          tipo: 'escala',\n          requerida: true\n        }, {\n          id: 2,\n          texto: '¿Qué aspectos mejoraría?',\n          tipo: 'abierta',\n          requerida: false\n        }, {\n          id: 3,\n          texto: '¿Recomendaría nuestros servicios?',\n          tipo: 'multiple',\n          opciones: ['Definitivamente sí', 'Probablemente sí', 'Probablemente no', 'Definitivamente no'],\n          requerida: true\n        }]\n      }, {\n        id: 2,\n        titulo: 'Evaluación de Capacitación',\n        descripcion: 'Encuesta post-capacitación para evaluar efectividad',\n        fechaCreacion: new Date('2025-09-15'),\n        fechaLimite: new Date('2025-11-15'),\n        estado: 'activa',\n        creadorId: 2,\n        preguntas: [{\n          id: 4,\n          texto: '¿El contenido fue claro y comprensible?',\n          tipo: 'multiple',\n          opciones: ['Sí, muy claro', 'Parcialmente claro', 'No muy claro', 'Confuso'],\n          requerida: true\n        }, {\n          id: 5,\n          texto: 'Califique la calidad del instructor (1-5)',\n          tipo: 'escala',\n          requerida: true\n        }]\n      }];\n      // Datos iniciales de respuestas\n      const respuestasIniciales = [{\n        id: 1,\n        encuestaId: 1,\n        usuarioId: 1,\n        respuestas: {\n          1: 4,\n          2: 'Mejorar los tiempos de atención',\n          3: 'Definitivamente sí'\n        },\n        fechaCompletado: new Date('2024-10-02'),\n        ipAddress: '192.168.1.100',\n        tiempoRespuesta: 180\n      }, {\n        id: 2,\n        encuestaId: 1,\n        usuarioId: 2,\n        respuestas: {\n          1: 5,\n          2: 'Todo perfecto',\n          3: 'Definitivamente sí'\n        },\n        fechaCompletado: new Date('2024-10-02'),\n        ipAddress: '192.168.1.101',\n        tiempoRespuesta: 120\n      }, {\n        id: 3,\n        encuestaId: 2,\n        usuarioId: 1,\n        respuestas: {\n          4: 'Sí, muy claro',\n          5: 5\n        },\n        fechaCompletado: new Date('2024-10-10'),\n        ipAddress: '192.168.1.100',\n        tiempoRespuesta: 90\n      }];\n      this.usuariosSubject.next(usuariosIniciales);\n      this.encuestasSubject.next(encuestasIniciales);\n      this.respuestasSubject.next(respuestasIniciales);\n    }\n    // CRUD Encuestas\n    obtenerEncuestas() {\n      return this.encuestas$;\n    }\n    obtenerEncuestaPorId(id) {\n      return of(this.encuestasSubject.value.find(e => e.id === id));\n    }\n    crearEncuesta(encuesta) {\n      const nuevaEncuesta = {\n        ...encuesta,\n        id: Math.max(...this.encuestasSubject.value.map(e => e.id)) + 1\n      };\n      const encuestasActuales = this.encuestasSubject.value;\n      this.encuestasSubject.next([...encuestasActuales, nuevaEncuesta]);\n      return of(nuevaEncuesta);\n    }\n    actualizarEncuesta(id, encuesta) {\n      const encuestasActuales = this.encuestasSubject.value;\n      const index = encuestasActuales.findIndex(e => e.id === id);\n      if (index === -1) {\n        return of(null);\n      }\n      encuestasActuales[index] = {\n        ...encuestasActuales[index],\n        ...encuesta\n      };\n      this.encuestasSubject.next([...encuestasActuales]);\n      return of(encuestasActuales[index]);\n    }\n    eliminarEncuesta(id) {\n      const encuestasActuales = this.encuestasSubject.value;\n      const nuevasEncuestas = encuestasActuales.filter(e => e.id !== id);\n      if (nuevasEncuestas.length === encuestasActuales.length) {\n        return of(false);\n      }\n      this.encuestasSubject.next(nuevasEncuestas);\n      return of(true);\n    }\n    // Validación de respuesta única por usuario\n    usuarioYaRespondio(encuestaId, usuarioId) {\n      const respuestas = this.respuestasSubject.value;\n      const yaRespondio = respuestas.some(r => r.encuestaId === encuestaId && r.usuarioId === usuarioId);\n      return of(yaRespondio);\n    }\n    // Enviar respuesta con validaciones\n    enviarRespuesta(respuestaCompleta) {\n      // Validar respuesta única\n      const yaRespondio = this.respuestasSubject.value.some(r => r.encuestaId === respuestaCompleta.encuestaId && r.usuarioId === respuestaCompleta.usuarioId);\n      if (yaRespondio) {\n        return of({\n          success: false,\n          message: 'Ya has respondido esta encuesta'\n        });\n      }\n      // Validar límites de tiempo (anti-spam básico)\n      if (respuestaCompleta.tiempoRespuesta && respuestaCompleta.tiempoRespuesta < 30) {\n        return of({\n          success: false,\n          message: 'Respuesta enviada muy rápido. Por favor, tómate tiempo para leer las preguntas.'\n        });\n      }\n      const nuevaRespuesta = {\n        ...respuestaCompleta,\n        id: Math.max(...this.respuestasSubject.value.map(r => r.id)) + 1\n      };\n      const respuestasActuales = this.respuestasSubject.value;\n      this.respuestasSubject.next([...respuestasActuales, nuevaRespuesta]);\n      return of({\n        success: true,\n        message: 'Respuesta enviada exitosamente'\n      });\n    }\n    // Obtener estadísticas por encuesta\n    obtenerEstadisticasEncuesta(encuestaId) {\n      const respuestas = this.respuestasSubject.value.filter(r => r.encuestaId === encuestaId);\n      const encuesta = this.encuestasSubject.value.find(e => e.id === encuestaId);\n      if (!encuesta) {\n        return of(null);\n      }\n      const estadisticas = {\n        encuestaId,\n        titulo: encuesta.titulo,\n        totalRespuestas: respuestas.length,\n        fechaInicio: encuesta.fechaCreacion,\n        fechaFin: encuesta.fechaLimite,\n        estado: encuesta.estado,\n        preguntasAnalisis: encuesta.preguntas.map(pregunta => {\n          const respuestasPregunta = respuestas.map(r => r.respuestas[pregunta.id]).filter(Boolean);\n          let analisis = {\n            preguntaId: pregunta.id,\n            texto: pregunta.texto,\n            tipo: pregunta.tipo,\n            totalRespuestas: respuestasPregunta.length\n          };\n          if (pregunta.tipo === 'escala') {\n            const valores = respuestasPregunta.map(Number).filter(Boolean);\n            analisis.promedio = valores.length > 0 ? valores.reduce((a, b) => a + b, 0) / valores.length : 0;\n            analisis.distribucion = this.calcularDistribucionEscala(valores);\n          } else if (pregunta.tipo === 'multiple') {\n            analisis.distribucion = this.calcularDistribucionMultiple(respuestasPregunta);\n          } else if (pregunta.tipo === 'abierta') {\n            analisis.respuestasTexto = respuestasPregunta.slice(0, 10); // Solo primeras 10 para el ejemplo\n          }\n          return analisis;\n        }),\n        tiempoPromedioRespuesta: respuestas.length > 0 ? respuestas.reduce((suma, r) => suma + (r.tiempoRespuesta || 0), 0) / respuestas.length : 0\n      };\n      return of(estadisticas);\n    }\n    calcularDistribucionEscala(valores) {\n      const distribucion = {};\n      for (let i = 1; i <= 5; i++) {\n        distribucion[i.toString()] = valores.filter(v => v === i).length;\n      }\n      return distribucion;\n    }\n    calcularDistribucionMultiple(respuestas) {\n      const distribucion = {};\n      respuestas.forEach(respuesta => {\n        if (distribucion[respuesta]) {\n          distribucion[respuesta]++;\n        } else {\n          distribucion[respuesta] = 1;\n        }\n      });\n      return distribucion;\n    }\n    // Obtener todas las respuestas\n    obtenerRespuestas() {\n      return this.respuestas$;\n    }\n    // Usuarios\n    obtenerUsuarios() {\n      return this.usuarios$;\n    }\n    crearUsuario(usuario) {\n      const nuevoUsuario = {\n        ...usuario,\n        id: Math.max(...this.usuariosSubject.value.map(u => u.id)) + 1\n      };\n      const usuariosActuales = this.usuariosSubject.value;\n      this.usuariosSubject.next([...usuariosActuales, nuevoUsuario]);\n      return of(nuevoUsuario);\n    }\n    actualizarUsuario(id, usuario) {\n      const usuariosActuales = this.usuariosSubject.value;\n      const index = usuariosActuales.findIndex(u => u.id === id);\n      if (index === -1) {\n        return of(null);\n      }\n      usuariosActuales[index] = {\n        ...usuariosActuales[index],\n        ...usuario\n      };\n      this.usuariosSubject.next([...usuariosActuales]);\n      return of(usuariosActuales[index]);\n    }\n    eliminarUsuario(id) {\n      const usuariosActuales = this.usuariosSubject.value;\n      const nuevosUsuarios = usuariosActuales.filter(u => u.id !== id);\n      if (nuevosUsuarios.length === usuariosActuales.length) {\n        return of(false);\n      }\n      this.usuariosSubject.next(nuevosUsuarios);\n      return of(true);\n    }\n    // Métodos de seguridad\n    // Inicializar sesión segura para usuario\n    inicializarSesionSegura(userId, ipAddress, userAgent) {\n      const sessionId = this.securityService.inicializarSesion(userId, ipAddress, userAgent);\n      this.sesionesUsuario.set(userId, sessionId);\n      return of(sessionId);\n    }\n    // Validar acceso a encuesta con verificaciones de seguridad\n    validarAccesoEncuestaSegura(userId, encuestaId) {\n      const sessionId = this.sesionesUsuario.get(userId);\n      if (!sessionId) {\n        return throwError(() => new Error('Sesión no iniciada'));\n      }\n      return this.securityService.validarAccesoEncuesta(sessionId, encuestaId);\n    }\n    // Responder encuesta con validaciones de seguridad\n    responderEncuestaSegura(userId, encuestaId, respuestaData, tiempoInicio) {\n      const sessionId = this.sesionesUsuario.get(userId);\n      if (!sessionId) {\n        return throwError(() => new Error('Sesión no válida'));\n      }\n      const tiempoRespuesta = Math.floor((Date.now() - tiempoInicio.getTime()) / 1000);\n      return this.securityService.validarRespuesta(sessionId, encuestaId, respuestaData, tiempoRespuesta).pipe(switchMap(validacion => {\n        if (!validacion.isValid) {\n          return throwError(() => new Error(validacion.message));\n        }\n        // Si la validación es exitosa, proceder con el guardado normal\n        const respuestaCompleta = {\n          encuestaId,\n          usuarioId: userId,\n          respuestas: respuestaData,\n          fechaCompletado: new Date(),\n          tiempoRespuesta\n        };\n        return this.enviarRespuesta(respuestaCompleta).pipe(map(result => {\n          if (!result.success) {\n            throw new Error(result.message);\n          }\n          // Retornar la respuesta creada\n          const respuestasActuales = this.respuestasSubject.value;\n          return respuestasActuales[respuestasActuales.length - 1];\n        }));\n      }));\n    }\n    // Obtener estadísticas de seguridad (solo para administradores)\n    obtenerEstadisticasSeguridad() {\n      return this.securityService.obtenerEstadisticasSeguridad();\n    }\n    // Desbloquear IP (solo para administradores)\n    desbloquearIP(ipAddress) {\n      this.securityService.desbloquearIP(ipAddress);\n    }\n    // Obtener IPs bloqueadas (solo para administradores)\n    obtenerIPsBloqueadas() {\n      return of(this.securityService.obtenerIPsBloqueadas());\n    }\n    // Cerrar sesión de usuario\n    cerrarSesion(userId) {\n      this.sesionesUsuario.delete(userId);\n    }\n    static ɵfac = function EncuestasService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || EncuestasService)(i0.ɵɵinject(i1.SecurityService));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: EncuestasService,\n      factory: EncuestasService.ɵfac,\n      providedIn: 'root' // Hacer que este servicio este disponible en toda la aplicacion\n    });\n  }\n  return EncuestasService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}